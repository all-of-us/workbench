{"name": "All of Us Python and SQL snippets", "sub-menu": [{"name": "Documentation", "external-link": "https://github.com/all-of-us/workbench-snippets"}, "---", {"name": "(1) Setup", "snippet": "import json\nimport os\nimport numpy as np\nimport pandas as pd\nimport plotnine\nfrom plotnine import *  # Provides a ggplot-like interface to matplotlib.\n\n# Get the BigQuery curated dataset for the current workspace context.\nCDR = os.environ['WORKSPACE_CDR']\n\n## Plot setup.\ntheme_set(theme_bw(base_size = 11)) # Default theme for plots.\n\ndef get_boxplot_fun_data(df):\n  \"\"\"Returns a data frame with a y position and a label, for use annotating ggplot boxplots.\n\n  Args:\n    d: A data frame.\n  Returns:\n    A data frame with column y as max and column label as length.\n  \"\"\"\n  d = {'y': max(df), 'label': f'N = {len(df)}'}\n  return(pd.DataFrame(data=d, index=[0]))\n\n## ---------------[ CHANGE THESE AS NEEDED] ---------------------------------------\n# Set default parameter values so that all snippets run successfully with no edits needed.\nCOHORT_QUERY = f'SELECT person_id FROM `{CDR}.person`'  # Default to all participants.\nMEASUREMENT_OF_INTEREST = 'hemoglobin'\n# Tip: the next four parameters could be set programmatically using one row from\n# the result of measurements_of_interest_summary.sql\nMEASUREMENT_CONCEPT_ID = 3000963        # Hemoglobin\nUNIT_CONCEPT_ID = 8636                  # gram per liter\nMEASUREMENT_NAME = '<this should be the measurement name>'\nUNIT_NAME = '<this should be the unit name>'\n"}, {"name": "(2) Participant counts", "sub-menu": [{"name": "total_number_of_participants.sql", "snippet": "\ntotal_number_of_participants_df = pd.io.gbq.read_gbq(f'''\n\n-- Compute the count of unique participants in our All of Us cohort.\nSELECT\n  COUNT(DISTINCT person_id) AS total_number_of_participants\nFROM\n  `{CDR}.person`\nWHERE\n  person_id IN ({COHORT_QUERY})\n\n''',\n  dialect='standard')\n\ntotal_number_of_participants_df.head()"}, {"name": "number_of_participants_with_measurements.sql", "snippet": "\nnumber_of_participants_with_measurements_df = pd.io.gbq.read_gbq(f'''\n\n-- Compute the count of unique participants in our All of Us cohort\n-- that have at least one measurement.\nSELECT\n  COUNT(DISTINCT person_id) AS number_of_participants_with_measurements\nFROM\n  `{CDR}.measurement`\nWHERE\n  person_id IN ({COHORT_QUERY})\n\n''',\n  dialect='standard')\n\nnumber_of_participants_with_measurements_df.head()"}, {"name": "number_of_participants_with_med_conditions.sql", "snippet": "\nnumber_of_participants_with_med_conditions_df = pd.io.gbq.read_gbq(f'''\n\n-- Compute the count of unique participants in our All of Us cohort\n-- that have at least one condition.\nSELECT\n  COUNT(DISTINCT person_id) AS number_of_participants_with_med_conditions\nFROM\n  `{CDR}.condition_occurrence`\nWHERE\n  person_id IN ({COHORT_QUERY})\n\n''',\n  dialect='standard')\n\nnumber_of_participants_with_med_conditions_df.head()"}]}, {"name": "(3) Summarize available measurements of interest", "sub-menu": [{"name": "measurements_of_interest_summary.sql", "snippet": "\nmeasurements_of_interest_summary_df = pd.io.gbq.read_gbq(f'''\n\n-- Compute summary information for our measurements of interest for our cohort.\n--\n-- PARAMETERS:\n--   MEASUREMENT_OF_INTEREST: a case-insensitive string, such as \"hemoglobin\", to be compared\n--                            to all measurement concept names to identify those of interest\n\nWITH\n  --\n  -- Use a case insensitive string to search the measurement concept names of those\n  -- measurements we do have in the measurements table.\n  --\n  labs_of_interest AS (\n  SELECT\n    measurement_concept_id,\n    measurement_concept.concept_name AS measurement_name,\n    unit_concept_id,\n    unit_concept.concept_name AS unit_name\n  FROM\n    `{CDR}.measurement`\n  LEFT JOIN `{CDR}.concept` AS measurement_concept\n  ON measurement_concept.concept_id = measurement_concept_id\n  LEFT JOIN `{CDR}.concept` AS unit_concept\n  ON unit_concept.concept_id = unit_concept_id\n  WHERE\n    REGEXP_CONTAINS(measurement_concept.concept_name, r\"(?i){MEASUREMENT_OF_INTEREST}\")\n  GROUP BY\n    measurement_concept_id,\n    unit_concept_id,\n    measurement_concept.concept_name,\n    unit_concept.concept_name\n)\n  --\n  -- Summarize the information about each measurement concept of interest that our\n  -- prior query identified.\n  --\nSELECT\n  measurement_name AS measurement,\n  IFNULL(unit_name, \"NA\") AS unit,\n  COUNT(1) AS N,\n  COUNTIF(value_as_number IS NULL\n    AND (value_as_concept_id IS NULL\n      OR value_as_concept_id = 0)) AS missing,\n  MIN(value_as_number) AS min,\n  MAX(value_as_number) AS max,\n  AVG(value_as_number) AS avg,\n  STDDEV(value_as_number) AS stddev,\n  APPROX_QUANTILES(value_as_number, 4) AS quantiles,\n  COUNTIF(value_as_number IS NOT NULL) AS num_numeric_values,\n  COUNTIF(value_as_concept_id IS NOT NULL\n      AND value_as_concept_id != 0) AS num_concept_values,\n  COUNTIF(operator_concept_id IS NOT NULL) AS num_operators,\n  IF(src_id = \"PPI/PM\", \"PPI\", \"EHR\") AS measurement_source,\n  measurement_concept_id,\n  unit_concept_id\nFROM\n  `{CDR}.measurement`\nINNER JOIN\n labs_of_interest USING(measurement_concept_id, unit_concept_id)\nLEFT JOIN\n  `{CDR}.measurement_ext` USING(measurement_id)\nWHERE\n  person_id IN ({COHORT_QUERY})\nGROUP BY\n  measurement_concept_id,\n  measurement_name,\n  measurement_source,\n  unit_concept_id,\n  unit_name\nORDER BY\n  N DESC\n\n\n''',\n  dialect='standard')\n\nmeasurements_of_interest_summary_df.head()"}]}, {"name": "(4a) Retrieve a measurement of interest", "sub-menu": [{"name": "measurement_of_interest.sql", "snippet": "\nmeasurement_of_interest_df = pd.io.gbq.read_gbq(f'''\n\n-- Return row level data for a measurement for our cohort.\n--\n-- PARAMETERS:\n--   MEASUREMENT_CONCEPT_ID: for example 3000963  # Hemoglobin\n--   UNIT_CONCEPT_ID: for example 8636            # gram per liter\n\nWITH\n  --\n  -- Retrieve participants birthdate and gender.\n  --\npersons AS (\n  SELECT\n    person_id,\n    birth_datetime,\n    concept_name AS gender\n  FROM\n    `{CDR}.person`\n  LEFT JOIN `{CDR}.concept` ON concept_id = gender_concept_id),\n  --\n  -- Retrieve the row-level data for our measurement of interest.\n  --\nmeasurements AS (\n  SELECT\n    person_id,\n    measurement_id,\n    measurement_concept_id,\n    measurement_date,\n    measurement_datetime,\n    measurement_type_concept_id,\n    operator_concept_id,\n    value_as_number,\n    value_as_concept_id,\n    unit_concept_id,\n    range_low,\n    range_high\n  FROM\n    `{CDR}.measurement`\n  WHERE\n    measurement_concept_id = {MEASUREMENT_CONCEPT_ID}\n    AND unit_concept_id = {UNIT_CONCEPT_ID}\n    AND person_id IN ({COHORT_QUERY}))\n  --\n  -- Lastly, JOIN all this data together so that we have the birthdate, gender and site for each measurement.\n  --\nSELECT\n  persons.*,\n  src_id,\n  measurements.* EXCEPT(person_id, measurement_id)\nFROM\n  measurements\nLEFT JOIN\n  persons USING (person_id)\nLEFT JOIN\n  `{CDR}.measurement_ext` USING (measurement_id)\nORDER BY\n  person_id,\n  measurement_id\n\n\n''',\n  dialect='standard')\n\nmeasurement_of_interest_df.head()"}, {"name": "measurement_of_interest_by_age_and_gender.plotnine", "snippet": "# This plot assumes that measurement_of_interest.sql has been run.\n\nmeasurement_of_interest_df['age_at_measurement'] = ((pd.to_datetime(measurement_of_interest_df['measurement_date'])\n                                     - measurement_of_interest_df['birth_datetime'].dt.tz_localize(None)).dt.days)//365.24\nmeasurement_of_interest_df['age_group'] = pd.cut(measurement_of_interest_df['age_at_measurement'],\n                                                 [-np.inf, 34.5, 49.5, 64.5, np.inf],\n                                                 labels=[\"<35\", \"35-49\", \"50-64\", \"65+\"])\n# meas_filter is a column of True and False\nmeas_filter = measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\nage_group_not_null = (measurement_of_interest_df['age_group'].notnull())\n\n(ggplot(measurement_of_interest_df[meas_filter & age_group_not_null], aes(x = 'age_group', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    facet_wrap('~ gender', nrow = len(measurement_of_interest_df.gender.unique())) +\n    xlab('age') +\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'All {MEASUREMENT_NAME} measurements, by age, faceted by gender\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 12)))\n"}, {"name": "measurement_of_interest_by_gender.plotnine", "snippet": "# This plot assumes that measurement_of_interest.sql has been run.\n\n# meas_filter is a column of True and False\nmeas_filter = measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\n(ggplot(measurement_of_interest_df[meas_filter], aes(x = 'gender', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'All {MEASUREMENT_NAME} measurements, by site\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 6), axis_text_x = element_text(angle=25, hjust=1)))\n"}, {"name": "measurement_of_interest_by_site.plotnine", "snippet": "# This plot assumes that measurement_of_interest.sql has been run.\n\n# meas_filter is a column of True and False\nmeas_filter = measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\n(ggplot(measurement_of_interest_df[meas_filter], aes(x = 'src_id', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'All {MEASUREMENT_NAME} measurements, by site\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 6)))\n"}]}, {"name": "(4b) Retrieve the most recent measurement of interest per person", "sub-menu": [{"name": "most_recent_measurement_of_interest.sql", "snippet": "\nmost_recent_measurement_of_interest_df = pd.io.gbq.read_gbq(f'''\n\n-- Return row level data for a measurement, limited to only the most recent result per person in our cohort.\n--\n-- PARAMETERS:\n--   MEASUREMENT_CONCEPT_ID: for example 3000963  # Hemoglobin\n--   UNIT_CONCEPT_ID: for example 8636            # gram per liter\n\nWITH\n  --\n  -- Retrieve participants birthdate and gender.\n  --\npersons AS (\n  SELECT\n    person_id,\n    birth_datetime,\n    concept_name AS gender\n  FROM\n    `{CDR}.person`\n  LEFT JOIN `{CDR}.concept` ON concept_id = gender_concept_id),\n  --\n  -- Retrieve the row-level data for our measurement of interest. Also compute\n  -- a new column for the recency rank of the measurement per person, a rank of\n  -- of 1 being the most recent lab result for that person.\n  --\nmeasurements AS (\n  SELECT\n    person_id,\n    measurement_id,\n    measurement_concept_id,\n    unit_concept_id,\n    measurement_date,\n    measurement_datetime,\n    measurement_type_concept_id,\n    operator_concept_id,\n    value_as_number,\n    value_as_concept_id,\n    range_low,\n    range_high,\n    ROW_NUMBER() OVER (PARTITION BY person_id\n                       ORDER BY measurement_date DESC,\n                                measurement_datetime DESC,\n                                measurement_id DESC) AS recency_rank\n\n  FROM\n    `{CDR}.measurement`\n  WHERE\n    measurement_concept_id = {MEASUREMENT_CONCEPT_ID}\n    AND unit_concept_id = {UNIT_CONCEPT_ID}\n    AND person_id IN ({COHORT_QUERY}))\n  --\n  -- Lastly, JOIN all this data together so that we have the birthdate, gender and site for each\n  -- measurement, retaining only the most recent result per person.\n  --\nSELECT\n  persons.*,\n  src_id,\n  measurements.* EXCEPT(person_id, measurement_id, recency_rank)\nFROM\n  measurements\nLEFT JOIN\n  persons USING (person_id)\nLEFT JOIN\n  `{CDR}.measurement_ext` USING (measurement_id)\nWHERE\n  recency_rank = 1\nORDER BY\n  person_id,\n  measurement_id\n\n\n''',\n  dialect='standard')\n\nmost_recent_measurement_of_interest_df.head()"}, {"name": "most_recent_measurement_of_interest_by_age_and_gender.plotnine", "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\n\nmost_recent_measurement_of_interest_df['age_at_measurement'] = ((pd.to_datetime(most_recent_measurement_of_interest_df['measurement_date'])\n                                                 - most_recent_measurement_of_interest_df['birth_datetime'].dt.tz_localize(None)).dt.days)//365.24\nmost_recent_measurement_of_interest_df['age_group'] = pd.cut(most_recent_measurement_of_interest_df['age_at_measurement'],\n                                                             [-np.inf, 34.5, 49.5, 64.5, np.inf],\n                                                             labels=[\"<35\", \"35-49\", \"50-64\", \"65+\"])\n# meas_filter is a column of True and False\nmeas_filter = most_recent_measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\nage_group_not_null = (most_recent_measurement_of_interest_df['age_group'].notnull())\n\n(ggplot(most_recent_measurement_of_interest_df[meas_filter & age_group_not_null], aes(x = 'age_group', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    facet_wrap('~ gender', nrow = len(most_recent_measurement_of_interest_df.gender.unique())) +\n    xlab('age') +\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'Most recent {MEASUREMENT_NAME} measurement\\nper person, by age, faceted by gender\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 6)))\n"}, {"name": "most_recent_measurement_of_interest_by_gender.plotnine", "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\n\nmeas_filter = most_recent_measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\n(ggplot(most_recent_measurement_of_interest_df[meas_filter], aes(x = 'gender', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'Most recent {MEASUREMENT_NAME} measurement\\nper person, by gender\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 6), axis_text_x = element_text(angle=25, hjust=1)))\n"}, {"name": "most_recent_measurement_of_interest_by_site.plotnine", "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\n\n# meas_filter is a column of True and False\nmeas_filter = most_recent_measurement_of_interest_df['value_as_number'] < 9999999 # Get rid of nonsensical outliers.\n(ggplot(most_recent_measurement_of_interest_df[meas_filter], aes(x = 'src_id', y = 'value_as_number')) +\n    geom_boxplot() +\n    stat_summary(fun_data = get_boxplot_fun_data, geom = 'text', size = 10,\n                 position = position_dodge(width = 0.9), va = 'top') +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    ylab(f'{UNIT_NAME}') +\n    ggtitle(f'Most recent {MEASUREMENT_NAME} measurement\\nper person, by site\\nSource: All Of Us Data') +\n    theme(figure_size=(12, 6)))\n"}]}]}