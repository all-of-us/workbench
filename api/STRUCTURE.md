# All of Us Workbench API Structure & Technologies

The _All of Us_ Workbench API is largely built on [Spring Boot](https://spring.io/projects/spring-boot). It also uses [Swagger](https://swagger.io/) for autogenerating REST APIs.

## Database

The primary application database is a [Google Cloud SQL](https://cloud.google.com/sql/) instance running MySQL. We modify its schema using [Liquibase](https://www.liquibase.org/) migrations, which live in [db/changelog/](https://github.com/all-of-us/workbench/tree/master/api/db/changelog).

When creating a new database migration, add an XML file to the changelog directory that describes the migration to perform. This new file should be named `db.changelog-###-description-of-migration.xml`, where ### is the number of the newest migration + 1. Then, add the file to the end of the [db.changelog-master.xml](https://github.com/all-of-us/workbench/blob/master/api/db/changelog/db.changelog-master.xml) file.

We generally name database objects in lower_snake_case.

Liquibase migrations are applied (indirectly) via a bash script called [db/run-migrations.sh](https://github.com/all-of-us/workbench/blob/master/api/db/run-migrations.sh). Do not run this script directly; instead, call one of the following `project.rb` commands:

- dev-up (starts a local dev server)
- run-local-all-migrations (runs migrations on the `workbench` and `cdr` schemas)
- run-local-rw-migrations (runs migrations only on the `workbench` schema)

## DAOs

Data Access Objects (DAOs) are interfaces that describe what operations the application can perform on the database. Generaly, we give DAOs the CamelCased name of the database table. All of the Workbench DAOs implement Spring [`CrudRepository`](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html), which means they can do simple operations like find-by-primary-key, save, delete-by-primary-key, etc.

CrudRepository also allows queries to be [automatically derived](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details) from the name of a method defined on the interface. As such, you will see methods like `findByUserIdAndWorkspaceId` with no apparent implementation. The implementation is generated by Spring.

To define a query that uses a foreign key, there are a couple of options. First, you could use `@JoinColumn`/`@[One|Many]ToOne` annotation on the corresponding DB Model, as described [below](#db-models). Second, you could use an [@Query](https://www.baeldung.com/spring-data-jpa-query) annotation to just describe the query in stringy SQL.

TODO: do we have a preference of which of those to do?

## DB Models

DB Models represent a single row of a single table in the database, possibly with extender tables attached. We denote DB models by prefixing `Db` to the name of the database table. DB models heavily use `javax.persistence` annotations to describe where in the database table each part of the model lives.

In order to automatically gather data from extender tables, we use the `@JoinColumn`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, and `@MappedBy` annotations. Documentation and blogs on the usage of these annotations can be found in these links:

- https://www.baeldung.com/jpa-join-column
- https://www.baeldung.com/hibernate-one-to-many
- https://www.baeldung.com/jpa-joincolumn-vs-mappedby
- https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/JoinColumn.html (contains See Also links to the rest of these annotations)

Examples of the use of these annotations can be found in the following places:

- [DbUser](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbUser.java)
- [DbAddress](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbAddress.java)
- [DbCohort](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/db/model/DbCohort.java)

Much of the structure of DB models can be autogenerated in IntelliJ by defining the class members and then doing Generate -> Getter and Setter and Generate -> `equals()` and `hashCode()`. This will not automatically add the required annotations - those must be added manually.

## Services and ServiceImpls

Services are interfaces that declare methods of business logic. ServiceImpls are classes implementing their correspondingly named Service and the business logic methods declared therein.

Practically, this allows one ServiceImpl to implement multiple interfaces. This is used in several `UserServiceImpl` and others to mixin [GaugeDataCollector](https://github.com/all-of-us/workbench/blob/master/api/src/main/java/org/pmiops/workbench/monitoring/GaugeDataCollector.java), which needs a different implementation per-service.

Services / ServiceImpls are generally named after a feature or functional area, like 'UserService', 'CohortService', or 'MonitoringService'.

ServiceImpls can call into other services, but we try to keep the number of dependencies down. We try to avoid having ServiceImpls call into a large number of DAOs, especially DAOs not directly related to the functional area for which the ServiceImpl is responsible. For instance, the `UserServiceImpl` calls into the `UserDao`, the `AdminActionHistoryDao`

ServiceImpls should handle only application logic. They should not need explicit knowledge of the database, the REST API, or the UI.

## Controllers

Controllers take Request objects from the API, call into the Service layer, and return Response objects back to the API. Controllers implement autogenerated [APIControllers](#apicontrollers).

Controller methods should generally be small and should not contain any actual logic. The most common conditional in the Controller layer should be checking a feature flag. Most of the work done by Controllers should be unpacking data from a Request object or packaging data into a Response object.

### Mappers

There are four types of models in the system - [API models](#swagger), [DB models](#db-models), and [API Request and Response](#requests-and-responses) models. Mappers are utility interfaces that own methods that convert between these types of models. We use [MapStruct](https://mapstruct.org/) annotations to describe these mappings and autogenerate the implementation of the Mappers.

## API

The actual REST API is defined in a series of YAML files according to the [Swagger OpenAPI spec](https://swagger.io/specification/). Swagger takes these YAML files, merges them, and generates all the classes defined by the YAMLs. The command to do so is `./project.rb compile-generated-java`.

One non-Swagger-standard thing about these YAML files is that the `tag` param is used to indicate which Controller / APIController an endpoint should be associated with.

Each REST endpoint is defined under `PATHS` in the YAML file.

### API Models

API models are defined under `DEFINITIONS` in the YAML file. Swagger autogenerates classes from these. Both API models and DB models are currently used in the Controller and Service layer. There is not currently consensus on whether the standard should switch to only using one or the other.

TODO: is the latter sentence true?

### Requests and Responses

Swagger interprets the data sent to a given endpoint according to the Request model definition associated with that endpoint and throws an error if the data is improperly formatted. Likewise, Swagger validates that the data being returned from a given endpoint conforms to the Response model definition associated with that endpoint and throws an error if it does not.

Technically, Requests and Responses are just more API model classes, similarly autogenerated by Swagger, but they are only used when communicating directly with the API layer. API models that represent business logic concepts are more freely used throughout the system.

### APIs, APIControllers and APIDelegates

APIs are interfaces declaring APIController methods, in a similar philosophy to how Services and ServiceImpls are separate. They map REST requests to function calls. APIDelegate calls. APIDelegates are interfaces implemented by Controllers. They have Both APIControllers and APIDelegates are autogenerated by Swagger.